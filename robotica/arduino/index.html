<html>
  <head>
    <style>
      table{ 
        width:50%; //Ocupa el 50% de l'amplada de la p√†gina
        border-collapse: collapse;// Evita que apareixin dobles linies a les cel¬∑les 
        margin: 20px auto;} //Marge de 20px a la part superior i centra la taula
      
      th,td{
        border: 1px solid #ddd; //Afegieix una vora fina d'un p√≠xel de color gris clar al voltant de totes les cel¬∑les th i td.
        padding: 10px auto; //Espai intern dins de cada cel¬∑la, per fer-la m√©s llegible.
        text-algin: center} //Centrar el text dins de cada cel¬∑la.
        
      thead{
        background: #f4f4f4; //Cavia el color del fons del thead a gris clar.
        font-weight: bold;} //Fa que la cap√ßelera de la aula estigui en negreta.
        
      tbody tr: nth-child(even){ //√âs una pseudoclasse aplicada a tr segons si es parell o imparell, even √©s parell i odd √©s imparell.
        background-color: #f9f9f9;}

      tbody tr: hover{  //√âs una pseudoclasse hover per quan passo per sobre amb el ratol√≠ pel contngut de la taula √©s fa m√©s fosc.
        background-color: #e2e2e2;}
    </style>
  </head>
  <body>
<h1> Conceptes generals de microcontroladors </h1>
<p> Els diferents microcontroladors tenen en com√∫ els seguents aspectes:</p>
<ul>
  <li>Tipus d'entrades i sortides: el microcontrolador t√© un processador tipus AVR o Espressif on es conecta entrades digitals, entrades anal√≤giques, sortides digitals i sortides anal√≤giques</li>
  <li>Les entrades i sortides digitals nom√©s funcionen amb 0 o 1 es a dir codi binari, zero significa 0 volts i 1 pot significar 5 volts o 3,3 volts depenent del microcontrolador i del pin que utilitzem. A aquestes entrades podem connectar per exemple interruptors, sensor "foscor/claror" </li>  
</ul>
<h2> Sortides anal√≤giques tipus PWM:DAC (Convertidor de digital a anal√≥gic)</h2>
<p> PWM significa modulaci√≥ de l'ample de banda, en angl√®s <i> Pulse Width Modulation</i> i √©s una forma d'aconseguir una sortida anal√≤gica a partir de diverses sortides digitals, molt r√†pides.</p>
<p>PWM es representa amb el s√≠mbol "~" tal com podem veure a la imatge seg√ºent d'un Arduino Uno</p>
<img src="arduino_uno.png" width="600" height="400">
<p>M√©s amunt podem veure que els pins n√∫meros 3, 5, 6, 9, 10 i 11</p>
<p> Aquests PWM s√≥n sortides anal√≤giques de 8 bits, en el cas d'Arduino Uno Rev3 d'acord amb el <a href="https://store.arduino.cc/en-es/products/arduino-uno-rev3"> fabricant </a>, mentres en el cas d'Arduino Uno Rev4, √©s de 12 bits segons el <a href="https://docs.arduino.cc/resources/datasheets/ABX00080-datasheet.pdf"> fabricant </a>, que l'anomena DAC, que vol dir Digital Analog Converter</p>
<p> Tenir 8 o 12 bits en un convertidor digital anal√≤gic o DAC (Digital Analog Converter) tipus PWM fa que tinguem 2<sup>8</sup> o 2<sup>10</sup> nivells diferents de corrent, √©s a dir, 256 nivells diferents o 2048 nivells diferents</p>
<p> Soposem que tant Arduino uno Rev3 com Rev4 poden donar 5 volts com a m√†xim. Quina seria la resoluci√≥ en milivolts de cada Arduino?</p>
<p> 5 vols dividit entre 256 dona 0.01953125 volts = 19.53125 milivolts per Arduino Uno Rev3</p>
<p> 5 vols dividit entre 2048 dona 0.00244140625 volts = 2.44140625 milivolts per Arduino Uno Rev4</p>
<p>Els milivolts anterior s√≥n la resoluci√≥ que aconseguim. Imaginem que volem regular la  intensitat d'un LED amb un Arduino Uno Rev3 aconseguim menys fluid i amb graons m√©s grans, es a dir canvis m√©s bruscs perque 256 canvis s√≥n menys que 2048 volts. A continuaci√≥ veurem una imatge que repreenta com combinant moltes senyals digitals r√†pidament sembla que generem un senyal anal√≤gic, aixo √©s la base del PWM.</p>
<img src="PMW.PNG" widht="600" height="450">
<p>Quan major √©s l'amplada del pols vol dir que major √©s el temps que la sortida digital est√† en voltatge alt, per exemple 5V i menys temps est√† a 0V, i per tant el promig  de tots els polsos √©s m√©s alt. En canvi si per exemple si cada pols √©s m√©s estret a 5V vol dir que estar√† m√©s temps a 0V, i per tant el promig  de tots els polsos √©s m√©s baix. A la imatge de a dalt es pot veure com s'encendria un LED o un motor funcionaria a una velocitat del 0%, 25%, 50%, 75%, 100%. Quin percentatge del senyal canviara en un cas i en un altre?</p>
  <ul>
    <li>(0,01953125/5)*100 = 0,390625%</li>
    <li>(0,00244140625/5)*100 = 0,048828125%</li>
  </ul>  
<p>A la taula a continuaci√≥ veuras els valors per defecte de la freq√º√®ncia PWM en Arduino Uno Rev3</p>
<table>
  <thead>
    <tr>
      <th>PIN de Sortida</th>
      <th>Freq√º√®ncia PWM (Hz)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PINS: 3, 9, 10 i 11</td>
      <td>490 Hz</td>
    </tr>
    <tr>
      <td>PINS: 5 i 6</td>
      <td>976 Hz</td>
    </tr>
  </tbody>
</table>

<p>Nota: la taula HTML anterior t√© una cap√ßelera com un document HTML, per√≤ √©s diu thead, en comptes de head i es la primera filera de la taula.
   T√© un cos anomenat tbody, en comptes de body i √©s la resta de la taula. 
   La taula la defineix el tag table que agrupa thead i tbody. Totes les fileres tant del thead com el tbody es defineixen amb el tag tr, que vol dir table row.
   Dintre de thead hi ha ellements indivituals que s√≥n cel¬∑les que pertanyen a la primera filera i s'anomenen th o table heading.
   En el table body hi ha tamb√© fileres tr per√≤ dintre d'aquestes fileres els elements individuals han de ser td, que significa table data. Per √∫ltim, s'han de tancar el table o el body.
  Tots aquest elements es poden modificar amb CSS i fer la taula amb un estil propi.</p>
<p>Les freq√º√®ncies baixes proueixen soroll en els motors. Per tant √©s preferible conectar motors als pins 5 i 6.</p>
<p>La freq√º√®ncia es la inversa del periode, 976 Hz o cicles per segon corespon a un per√≠ode de 1/976 segons que √©s igual a 1,024 milisegons</p>
<h2>Convertidor anal√≤gic-digtal</h2>
<p>Apliquem el teorema de Nyquist que diu que hem de fer el doble de mostres com a minim que la freq√ºencia m√†xima per aconseguir convertir en senyal analogic cont√≠nu en un senyal digital mostrejat segons la figura seg√ºent</p>
<img src="nyquist.jpeg" witgh="600" height="400">
  <p>Nyquist √©s important, perque si en el codi poso una freq√º√®ncia de mostreig de 20 Hz per un so, no funcionar√†, perque la freq√º√®ncia m√≠nima del so es de 20 Hz i la m√†xima 20 kHz, pel que es refereix al so audible en humans. Aix√≤ es per que agafem mostres massa grans, i no opdem veure pujades i baixades de la senyal</p>
  <p>A continuaci√≥ veurem una taula comparativa sobre els micrcontroladors Arduino uno i ESP32S3 i el circuit ADS1115</p>
  <table>
    <thead>
      <tr>
        <th>Microcontrolador o circuit</th>
        <th>N√∫mero de bits (nivells)</th>
        <th>Voltatge</th>
      </tr>
      <tr>
        <td>Arduino uno</td>
        <td>10 (0-1023)</td>
        <td>0-5V / 0-3.3V</td>
      </tr>
      <tr>
        <td>ESP32S3</td>
        <td>12 (0-4095)</td>
        <td>0-3.3V</td>
      </tr>
      <tr>
        <td>ADS1115</td>
        <td>16 (0-65536)</td>
        <td>0-3.3V</td>
      </tr>
    </thead>
  </table>
<p> A continuaci√≥ tenim un codi general que pot servir per moltissimes coses diferents, i totes relacionades amb la capacitat que t√© l'Arduino de llegir de 0 a 1023 en una entrada anal√≤gica, si fos un ESP32S3 llegiria de 0 a 4095 i si fos un ADS1115 llegiria de 0 a 65536. Per qu√®?
Els microxips i els microcontroladors tenen transistors i aquests nom√©s poden fer una cosa, encendre's o apagar-se, √©s a dir 0 o 1 i cada bit √©s un 0 o 1. Si tenim 12 bits en un ADC (Analog Digital Converter) significa que t√© 2 <sub>12</sub> combinacions de zeros i uns, √©s a dir, 4096 nivells diferents que numericamentva des del 0 al 4095. Ara justifiquem el n√∫mero 65536 seria correcte si fos 2<sup>16</sup> com diu el fabricant, pero al datasheet parla d'un nivell m√†xim de 8000h (N√πmero hexadecimalque corrwspon a 32768) es a dir s√≥n 15 bits utilitzables. Sempre s'ha de comprobar el <a href="#"> datasheet o  fulla de caracter√≠stiques </a>del fabricant</p>
 
  <pre><code>
    int valor_ADC=0;  // Int significa integer o valor enter num√©ric (float seria "floating point number o decimal", char seria un character o caracter de lletra de l'alfabet, string seria una cadena de car√†cters o paraula, etc. El m√©s important √©s que la primera paraula defineix el tipus de paraula que tenim, en aquest cas enter). "valor_ADC" √©s un nom que triem nsaltrs per definir una variable, √©s a dir, un valor que no ser√† constant, i que t√© inicialment un valor 0, si posem int valor_ADC; √©s a dir, no posem que √©s igual a 0 per defecte hauria de donar valor 0. Si jo volgu√©s posar un potenciomentre possaria pot i si volgu√©s posar un LDR posaria ldr en min√∫scula. Sempre la primera l√≠nea √©s la definici¬¥de les variables. A vegades abans de la primera l√≠nea necessitem carregar biblioteques. 
    void setup(){    //9600 en Arduino 
                    // Sempre hi ha un setup o funci√≥ de configuraci√≥ del microcontrolador en llenguatge Arduino que t√© un parentasis buit perqu√® no t√© cap par√†metre o argument del qual depengui en molts casos. La paraula void seria l'equivalent a la paraula function en JavaScript. Tamb√© es diu void setup en Processing perqu√® deriva de Processing aquest llenguatge. Posem una clau per agrupar totes les instruccions que volem executar una sola vegada, perque setup s'executa nom√©s al principi quan arranquen o encenem l'Arduino o microcontrolador.  
    Serial_begin(9600);  //115200 en S3
                        // Serial s'escriu amb majuscules perqu√® √©s una classe que √©s una part important del codi Arduino que antigamnt era una classe de Processing i t√© un m√©tode que es fa servir amb la sintaxi del punt, dot syntax que consisteix en que quan j escric un punt estic aplicant un m√®tode normalment a un objecte d'una classe i a vegades a una classe, com aqu√≠. El m√®tode begin connecta per al cable serie del ordinador amb l'Arduino, i t√© nom√©s un par√†metre que √©s un n√∫mero enter que correspon a la velocitat en bits/segon. Pel cas de l'Arduino Uno 9600 bits/segon o bauds, mentres que en ESP32S3 s√≥n 115200 bits/segon o bauts "Serial.begin (115200)". √âs molt important posar un ; en cada insucci√≥ per informar que ja ha acabat.   
    }
    void loop(){          // √âs una funci√≥ que repeteix sense parar fins que desconecto f√≠sicament o poso un codi per aturar-ho
    valor ADC=analogRead(A0);  //34 en S3
                              // La variable que hem creat abans, que era 0 inicialment ara canviar√† perqu√® la instrucci√≥ analogRead el que fa √©s llegir valors entre 0 i 1023 si es un Arduino Uno, A0 √©s una de les 6 entrades anal√≤giques
    valor_ADC=analogRead(34); // La variable de valor 0 ara estar√† entre els valors 0 i 4095 Perqu√® √©s un microcontrolador de 12 bits ADC
                    //ADC √©s Analog Digital converter, √©s a dir que convertim un valor anal√≤gic en digital (convertidor anal√≤gic digital)
                    // DAC √©s Digital Analog Converter, √©s a dir el contrari que ADC, convertim digital a anal√≤gic com el PWM (Pulse Width Modlation) que vol dir modulaci√≥ de l'ample de banda
                // D'acord amb el <a src="https://www.espressif.com/sites/default/files/documentation/esp32-s3_datasheet_en.pdf"> datasheet o fulla de caracter√≠sitques de ESP32S3 </a>
                // Hi ha 20 entrades anal√≤giques de 12 bits mentres que en Arduino Uno hi ha 6 entrades anal√≤giques de 10 bits
    Serial.println(valorADC); // Println significa que imprimeixi via serial el valor de ADC (0-1023 o 0-4095)
    delay(500); //Espera 500 milisegons o mig segons per mostrar el resultat
  </code></pre>
  <p> Com podem veure a la foto de m√©s amunt d'arduino a la contonada inferior dreta es troben els 6 ADCs o entrades anal√≥giques amb les lletres d'A0 fins a A5, i la part superior de l'Arduino podem veure els pins que s√≥n els 6 DACs o sortides anal√≤giques de tipus PWM que estan senyalades amb ~ (Pins 3, 5, 6, 9, 10, 11).</p>
  <p> En la image seg√ºent podem veure un esquema de ESP23S3</p>
  <img src="esp32s3.webp" width="800" height="600">
  <p> Podem observarr que a difer√®ncia d'Arduino Uno la gran majoria de pins son GPIO, que significa General Purpose Input Output, en catal√† Pin d'entrada i sortida de prop√≤sit general, √©s a dir, que pot tenir moltes utilitats, entrada digital, sortida digital, entrada anal√≤gica, sortida anal√≤gica. Si volem veure un esquema dels pins podem escriure "pinout".</p>
  <p>Alguns pins s√≥n RTC, que significa Real Time Clock, que √©s un rellotge intern que funciona mitjan√ßant una pila interna que dona suficient energia perque vibri un cristall de quars que √©s el que compta el temps</p>
  <p> En el codi tenim un pin 34 que √©s un pin intern qu no veu l'usuari, perqu√® est√† a la placa base fent la funci√≥ SPIQ, segons el Datasheet el GTIO34 correspon al pin f√≠sic 39, per tant sempre hem de mirar el Pin Out oficial</p>
<h3> Com funciona les entrades anal√≥giques dels microcontroladors?</h3>
  <p> Els pins A0 fins A5 s√≥n entrades anal√≥giques i all√† podem connectar una s√©rie d'elements: </p>
    <ul>
      <li> Sensor de llum: LDR (light dependent resistor), Fotodiodes, C√©l¬∑lules solars</li>
      <li> Sensors de temperatura: LM35 (t√© una sortida lineal, 10 milivolts √©s un grau centrigrads i un rang -55 +150 semblant a TMP36, t√© menys rang i √©s menys prec√≠s), DHT11 O DHT22, mesuren temperatura i humitat i el 22 √©s m√©s prec√≠a que el 11, DS18820 t√© protocol one-wire</li>
    </ul>
  <h4> Exemple amb el sensor de temperatura LM35</h4>
   <pre>
     <code>
 const int sensorPin= A0;

void setup()
{
  Serial.begin(9600);
}

void loop()
{
  int value = analogRead(sensorPin);
  float millivolts = (value / 1023.0) * 5000;
  float celsius = millivolts / 10; 
  Serial.print(celsius);
  Serial.println(" C");
  delay(1000); // Mirem aquest codi i quins valors donaria. Entre 0 i 500 graus, √©s a dir, no dona valors negatius, i no coincideix entre -55 i 150 en resposta lineal mapejada
}       
     </code>
   </pre>
<p> El codi de m√©s amunt funcionaria amb un sensor de temperatura LM35, per√≤ es podria adaptar per qualsevol sensor
perque? Si soc un Arduino, els pins A0 - A5 nom√©s soc capa√ß de fer una cosa, llegir el senyal del sensor entre
0 i 1023. Mentres que en els pins PWM seria capa√ß d'escriure de 0 - 255</p>
  <p> const int sensorPin= A0; Significa que el valor √©s cons o constant, i que no variar√† en tot el codi, int que √©s
  un variable que √©s de tipus integer o n√∫mero enter, sensorPin √©s el nom que trio per identificar el pin anomenat A0
  i podia haver triat qualsevol altre nom, com: sensorT, sonsorTemperatura, sensorLM35... Per tant la instruacci√≥ sencera
  que fa? Estem donant un nom al pin A0 per identificar-lo i que sigui una constant en tot el codi que no pot variar, perque
  si varia, canvia el n√∫mero de pin</p>
    <p>void setup()
{
  Serial.begin(9600);
}
 Tots els codis sempre tenen les mateixes parts, al principi es posarien les biblioteques necessaries, seguides de les variables
    que necessiten (en aquest cas sensorPin) i a continuaci√≥ va el bloc de codi o funci√≥ de configuraci√≥ anomenada setup,
      el setup s'executa una sola vegada i  Serial.begin(9600); el que fa √©s aplicar el m√®tode begin amb la sintaxi del punt 
      (dot syntax) amb un argument o par√†metre que est√† entre par√®ntesis. Serial vol dir comunicaci√≥ en serie a trav√©s d'una
      cable USB, 9600 √©s la velocitat en bits per segon a trav√©s del cable USB. En un ESP32S3 es comunica una velocitat m√©s alta
      115200 bits per segon i aquesta velocitat no nom√©s ha d'estar al codi, sin√≥ que ha de coincidir en el IDE o entorn de 
      programaci√≥ d'Arduino, concretament a la consola de sortida de comunicaci√≥ s√®rie. Si no ho faig poden sortir car√†cters
      extranys quan premo el bot√≥ superior dret de comunicaci√≥ s√®rie. El punt i coma final √©s molt important, prque indica que he 
      acabat la instrucci√≥. </p>
  <p> Per finalitzar hi ha el codi principal o loop que es repeteix sense parar </p>
    <p> int value = analogRead(sensorPin); int √©s integer i nom√©s agafa n√∫meros enters, value √©s el nom que vull posar per
    enmmagatzemar tots els valor que va agafant Arduino. Com els emmagatzemo? Amb la instrucci√≥ analogRead que llegeix de 
    0 a 1023 i un cop llegit, el sensor pin (el par√†metre) el guarda dins de value.</p>
    <p> <b>float millivolts = (value / 1023.0) * 5000; </b> float significa floating point number, o n√∫mero decimal en angl√©s, millivolts
    √©s el nom de la variable on emmagatzemem els mollivolts reals que est√† generant el sensor de temperatura. Perqu√® genera en 
    millivolts? Perque l'Arduino Uno funciona a 5V o 5000mV, que passa si divideixo el valor entre 1023, que tinc el valor en tant
    per 1, i si aquest valor en tant per 1 ho multiplico per 5000 em donen 1023 valors diferents entre 0 i 5000.
    Posem diversos exemples: que passaria si el value √©s 0, que passaria si el value √©s 10? 10/1023x5000 = 49 millivolts, si 
    fosin 100 = 488 millivolts, si fosin 500 donaria 500/1023x5000= 2443 millivolts. Aix√≤ passaria amb tots els sensors</p>
    <p> Com seria si fos un ESP32S3? Seria 3.3V i 4095, per tant el codi seria <b>float millivolts = (value / 4095.0) * 3300; </b>
      i aconseguiriem millor resoluci√≥ o presici√≥, es a dir, el termometre o sensor agafaria m√©s valors diferents (seria m√©s precis).
      value / 4095 sempre ser√† un n√∫mero entre 0 i 1 perque value va enttre 0 i 4095, i si el multiplico per 3300 tindr√© un n√∫mero de 0 a 3300 millivolts
    <p><b> float celsius = millivolts / 10; </b>float demana un n√∫mero decimal, millivolts sempre donar√† entre 0 i 5000. Que passa si divideixo entre 10? Que converteix els els millivolts en graus, i van de 0 a 500 graus</p>
    <p> <b>Serial.print(celsius);</b> Aquest codi imprimeix a la pantalla el valor de la variable Celcius que anir√† des de 0 fins a 500 graus. </p>
    <p> <b>Serial.println(" C");</b> imprimeix una l√≠nea (println significa print line), i si ho posem entre cometes la C ("C") ho imprimeix tal qual a diferencia de si no posem cometes com celcius que apareix el valor de la veriable, √©s a dir, √©s un n√∫mero que canvia. Serial √©s una forma de communicar-se a trav√©s del USB o Comunicaci√≥ S√®rie, i en molts llenguatges de programaci√≥ existeix la biblioteca "Serial" o la classe Serial. Un llenguatge de programaci√≥ √©s un conjunt de biblioteques, una biblioteca √©s un conjunt de classes, i una classe cont√© diferents funcions.</p>
    <p> Per exemple, Arduino √©s i era una classe de llenguatge Processing, i s'utilitza molt m√©s Arduino com a llenguatge de programaci√≥ actualment. Si utilitzo processing i la biblioteca Arduino, l'avantatge que tinc √©s que puc utilitzar totes les biblioteques de visi√≥ per ordinador, d'intel¬∑ligencia artificial de l'ordinador i fer aplicacions que nom√©s amb Arduino serien impossible</p>
    <img src="lm35.png">
    <p> La imatge anterior procedeix de la fulla de caracter√≠stiques de LM35, i es veu que t√© una resposta lineal del voltatge i de la temperatura, de forma que a 2.9V ens donaria -55 graus i a 4.15V ens donaria 155 graus. Com fariem el codi de mapeig per aix√≤?</p>
     float temp = map (value,0,1023,2900,4150); 
    <p> Value √©s un valor que agafa amb la instrucci√≥ analogRead i va entre 0 i 1023 (en aquest cas) perque √©s un conversor d'anal√≤gica a digital de 10 bits 2^10, el transforma en un entre 2900 i 4150 millivolts</p>
     float celsius = map (temp,2900,4150,-55,150); 
    <p> La variable <b>temp</b> no cont√© temperatura, sin√≥ millivolts i els convertim d'aquesta manera perque la fulla de caracter√≠stiques de LM35 diu que hi ha una resposta lineal, vista en el gr√†fic de m√©s amunt entre els millivolts mesurats i la temperatura en celcius</p>
    <p> Qu√® passaria si utilitzo ESP32S3 i no Arduino respecre als resultats de mesura de temperatura? </p>
    <p> El codi canviar√† de la seguent manera: </p>
    
  int value = analogRead(sensorPin);
  float millivolts = (value / 4096.0) * 5000;
  float celsius = millivolts / 12; 
  Serial.print(celsius);
  Serial.println(" C");
  delay(1000);
     float temp = map (value,0,4095,2900,4150); 
     float celsius = map (temp,2900,4150,-55,150); 
<p> Canvia ja que hi t√© 12 bits, que √©s 2^12 que dona 4095 i s'hauria de connectar a 5 volts, ja que √©s pot connectar tamb√© a 3.3 volts, per√≤ no es llegiria correctament.</p>
<p> Quina mesura donaria en un o altre controlador?</p>
  <p> En ESP32S3 tenim 4096 nivells diferents i tenim 1250 millivolts disponibles (4150 - 2900).</p>
<p> Quina √©s la resoluci√≥ que tinc per cada nivell?</p>
  <p> 1250/4096, que dona 0.30517578125, que vol dir que cada vegada que augmenta un n√∫mero de nivell augmenten 0.305 millivolts</p>
<p> Aix√≤ quant seria en graus?</p>
  <p> Tindriem 205 graus de difer√®ncia de temperatura (sempre), per tant la resoluci√≥ seria m√©s baixa en el cas de 1024 nivells que en el cas de 4096 nivells, que seria m√©s alt, no importa el valor intermig.</p>
    <h1> Sensor LM35</h1>
    <p> √âs un sensor de temperatura lineal que t√© 3 pins, com es pot veure a la imatge seg√ºent:</p>
    <img src="sensor_lm35.png">
    <p> A continuaci√≥ tenim el gr√†fic de funcionament procedent del full de caracter√≠stiques</p>
    <img src="lm35.png">
    <p> Per √∫ltim veurem el cirquit f√≠sic d'Arduino: </p>
    <img src="arduino_lm35.png"
      <p> Hem vist que 2100 millivolts fins a 4350 millivolts la resposta de LM35 √©s lineal i va des de -55 fins a 150 graus. Com ho traduim al codi?</p>
      <p> Primer hem d'entendre que Arduino la seva entrada anal√≥gica √©s A0 (o qualsevol fins a A5) √©s capa√ß de llegir el voltatge i sempre comen√ßa amb zero i acaba amb 5 volts. Com hi ha 1024 nivells diferents, la resoluci√≥ √©s 5000/1024 = 4,88 millivolts. √âs a dir, la resoluci√≥ en millivolts √©s 4,88 (5000 s√≥n millivoltsperque Arduino Uno funciona a 5v). </p>
      <p> Comcomen√ßa a mesurar temperatures entre 29000 millivolts i 4100 millivolts hem de saber a qu√® correspon aquests dos n√∫meros en base 1024, (2900/5000)*1024 = 594 el nivell respecte 1024. (4100/5000)*1024 = 840 el nivell respecte 1024</p>
      <p> Sabent aix√≤, com seria el mapeig?</p>
      <pre>
        <code>
          int analogValue = analogRead (A0);
          float volt = analogValue*(5000/1024);
          float temp = map (analogValue,0,1023,-55,150); √âS INCORRECTE
          float temp = map (volt,594,840,-55,150); √âS CORRECTE
          // valors de volt des de 0 a 5000 perque 0*5000/1024 = 0 i 1024*5000/1024 = 5000
          // 500 analogValue 
        </code>
      </pre>
  </div>
        <div class="content-container">
        <p>L'objectiu del codi seg√ºent √©s entendre que les cadenes o strings s√≥n conjunts de car√†cters ASCII i podem accedir 
            amb ells amb arrays que esta formats per par√®ntesis quadrats i el primer element √©s el 0. En llenguatge C i derivats
            del C com Arduino podem utilitzar punters o pointers que permeten apuntar a un element. En python o JavaScript no hi
            ha punters.</p>
            <p>A continuaci√≥ veuras els caracter ASCII en una taula, que son els utilitzats en els strings o cadenes</p>
            <p>La taula seg√ºent est√† basada en un codi binari de 7 bits, perque 2 elevat a 7 (2^7) es 128, hi hauran desde 0 a 
               127 car√†cters diferents</p>
        <table>
            <thead>
                <tr>
                    <th>ASCII</th>
                    <th>DECIMAL</th>
                    <th>BINARI</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>A-Z</td>
                    <td>65-90</td>
                    <td>1000001-1011010</td>
                </tr>
                <tr>
                    <td>a-z</td>
                    <td>97-122</td>
                    <td>1100001-1111010</td>
                </tr>
                <tr>
                    <td>0-9</td>
                    <td>48-57</td>
                    <td>110000-111001</td>
                </tr>
                <tr>
                    <td>espai</td>
                    <td>32</td>
                    <td>100000</td>
                </tr>
            </tbody>
            </th>
        </table>
        <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb l'objectiu 
            d'intercambiar informaci√≥ amb ordinadors</p>
        <p>UTF8 √©s un sistema Unicode Transformation Format que permet escriure m√©s d'un mili√≥ de car√†cters diferents
            ‚ÄúüôÇ‚Äù U+1F642</p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                // sketch 05-03

                char message[] = "Hello";
                
                void setup() {
                  Serial.begin(9600);
                  message[0] = 'h';
                }
                
                void loop() {
                  Serial.println(message);
                  delay(1000);
                }
            </code></pre>

        </div>
  </body>
</html>
