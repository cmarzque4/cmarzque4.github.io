<!DOCTYPE html>
<html lang="ca">
<head>
    <style> 
        
        /*Aquest llenguatge es CSS o fulles d'estil, determina els estils (tipus de lletra, colors, marges...) i sempre té la mateixa estructura: nometiquetahtml{propietat1:valor1;propietat2:valor2;} Per exemple :

  canvas{
    border:purple 5px solid;
    margin:5px;
}
 
.content-container {
            margin-left: 10px;
            margin-right: 10px; 
            margin-top: 20px; 
        }
    </style>
</head>
<body>

<!-- Contingut principal -->
    /* llenguatge HTML -> determina la part visible de la pàgina (frases,botons, capceleres...)
<div class="content-container">
           <h3>Càlcul  de la posició d'un robot amb dos braços</h3>
        <label for="a1"> longitud del primer braç (a1):</label> (label= Entrada d'informació fixa)
        <input type="number" id="a1" value="2" steps="0.1"><br><br> (input= entrada d'informació per l'usuari"número, text, data")
        <label for="a2"> Longitud del segon braç (a2):</label> 
        <input type="number" id="a2" value="1.5" step="0.1"> (id= identificador d'elements)
        <label for="q1"> Longitud del primer braç (q1, en graus):</label>
        <input type="number" id="q1" value="45" step="0.1">  (value= valor per defecte)
        <label for="q2"> Longitud del segon braç (q2, en graus):</label>
        <input type="number" id="q2" value="30" step="0.1">  (step= variabilitat que jo puc escriure)

    <Button onclick="calculatePosition()">Calcula la posició:</button>
      <script lang="javascript"> /* java -> determina els càlculs no visibles de la pàgina
          let x1, x2, y1, y2;
       function calculatePosition() {
                //agafar les dades introduides per l'usuari
                let a1 = parseFloat(document.getElementById('a1').value); //longitud primer braç 
                let a2 = parseFloat(document.getElementById('a2').value); //longitud segon braç 
                let q1_deg = parseFloat(document.getElementById('q1').value); //angle en graus del primer braç
                let q2_deg = parseFloat(document.getElementById('q2').value); //angle en graus del segon braç
                (let= crea variables dins d'una funció)
                let output = "<div class='equation'> Les equacions per calcular la posició final  del robot son:</div>";
                output += "<div class='equation'>\\[ x = a_1 \\cos(q1) + a_2 \\cos(q_1 + q_2) \\] </div>";
                output += "<div class='equation'>\\[ y = a_1 \\sin(q1) + a_2 \\sin(q_1 + q_2) \\] </div>";
               //Càlculs numérics detallats
                x1 = a1 * Math.cos(q1); // Posició en x  del primer braç
                x2 = a2 * Math.cos(q1 + q2); // Posició en x  del segón braç
                y1 = a1 * Math.sin(q1); // Posició en y  del primer braç
                y2 = a2 * Math.sin(q1 + q2); // Posició en y  del segón braç
               output += "<div class='equation'>Desglossant els càlculs:</div>";
                output += "<div class='equation'>\\[x_1 = a_1 \\cos(q_1) + ${a1} \\times \\cos(${q1_deg}&deg;) = ${x1. toFixed(2)}\\]</div>";
                output += "<div class='equation'>\\[x_2 = a_2 \\cos(q_1 + q_2) + ${a2} \\times \\cos(${q1_deg}&deg;) + (${q2_deg}&deg;)= ${x2. toFixed(2)}\\]</div>";
                output += "<div class='equation'>\\[y_1 = a_1 \\sin(q_1) + ${a1} \\times \\sin(${q1_deg}&deg;) = ${y1. toFixed(2)}\\]</div>";
                output += "<div class='equation'>\\[y_2 = a_2 \\sin(q_1 + q_2) + ${a2} \\times \\sin(${q1_deg}&deg;) + (${q2_deg}&deg;)= ${y2. toFixed(2)}\\]</div>";           
               //Càlcul de les coordenades finals (x, y)
                let x= x1 + x2
                let y= y1 + y2
                output += "<div class='equation'> Calculant els resulats numèrics totals </div>";      
          
        // Dibuixar graficament el robot amb els dos braços
        let canvas = document.getElementById('robotCanvas');
        let centerX = canvas.width / 2; // punt mitjà de X
        let centerY = canvas.height / 2; // punt mitjà de Y
        let x1_screen = centerX + x1*scale;
        let y1_screen = centerY + y1*scale;
        let x2_screen = centerX + x2*scale;
        let y2_screen = centerY + y2*scale;

          ctx.beginPath(); (comença a dibuixar)
          ctx.moveTo(centerX, centerY); (mou al centre)
          ctx.lineTo(x1_screen, y1_screen); (línia des del centre del canvas)
          ctx.stroke();
          ctx.beginPath(); //com que té dos parentesis també és una funció
          ctx.moveTo(x1_screen, y1_screen); // (comença al final del primer braç)
          ctx.lineTo(x2_screen, y2_screen); // (recta de x1/y1 a x2/y2)
           }
          
    </script>
</body>
</html>


<html>
  <head>
    <style>
      table{ 

      th,td{
        border: 1px; (afegeix una vora fina)
        padding: 10px; (Espai intern dins de cada cel·la)
        text-algin: center (centra el text)
      } 
        
      thead{
        background: #; (color del fons del thead)
        font-weight: bold;
      }
        
    </style>
  </head>
  <body>
<h2> Sortides analògiques tipus PWM</h2>
<p> PWM significa modulació de l'ample de banda, en anglès <i> Pulse Width Modulation</i> i és una forma d'aconseguir una sortida analògica a partir de diverses sortides digitals, molt ràpides.</p>
<p>PWM es representa amb el símbol "~" tal com podem veure a la imatge següent d'un Arduino Uno</p>
<img src="arduino_uno.png" width="600" height="400">
<p>Més amunt podem veure que els pins números 3, 5, 6, 9, 10 i 11</p>
<p> Aquests PWM són sortides analògiques de 8 bits, en el cas d'Arduino Uno Rev3 d'acord amb el <a href="https://store.arduino.cc/en-es/products/arduino-uno-rev3"> fabricant </a>, mentres en el cas d'Arduino Uno Rev4, és de 12 bits segons el <a href="https://docs.arduino.cc/resources/datasheets/ABX00080-datasheet.pdf"> fabricant </a>, que l'anomena DAC, que vol dir Digital Analog Converter</p>
<p> Tenir 8 o 12 bits en un convertidor digital analògic o DAC (Digital Analog Converter) tipus PWM fa que tinguem 2<sup>8</sup> o 2<sup>10</sup> nivells diferents de corrent, és a dir, 256 nivells diferents o 2048 nivells diferents</p>
<p> Soposem que tant Arduino uno Rev3 com Rev4 poden donar 5 volts com a màxim. Quina seria la resolució en milivolts de cada Arduino?</p>
<p> 5 vols dividit entre 256 dona 0.01953125 volts = 19.53125 milivolts per Arduino Uno Rev3</p>
<p> 5 vols dividit entre 2048 dona 0.00244140625 volts = 2.44140625 milivolts per Arduino Uno Rev4</p>
<p>Els milivolts anterior són la resolució que aconseguim. Imaginem que volem regular la  intensitat d'un LED amb un Arduino Uno Rev3 aconseguim menys fluid i amb graons més grans, es a dir canvis més bruscs perque 256 canvis són menys que 2048 volts. A continuació veurem una imatge que repreenta com combinant moltes senyals digitals ràpidament sembla que generem un senyal analògic, aixo és la base del PWM.</p>
<img src="PMW.PNG" widht="600" height="450">
<p>Quan major és l'amplada del pols vol dir que major és el temps que la sortida digital està en voltatge alt, per exemple 5V i menys temps està a 0V, i per tant el promig  de tots els polsos és més alt. En canvi si per exemple si cada pols és més estret a 5V vol dir que estarà més temps a 0V, i per tant el promig  de tots els polsos és més baix. A la imatge de a dalt es pot veure com s'encendria un LED o un motor funcionaria a una velocitat del 0%, 25%, 50%, 75%, 100%. Quin percentatge del senyal canviara en un cas i en un altre?</p>
  <ul>
    <li>(0,01953125/5)*100 = 0,390625%</li>
    <li>(0,00244140625/5)*100 = 0,048828125%</li>
  </ul>  
<table>
    <thead>
      <tr>
        <th>Microcontrolador o circuit</th>
        <th>Número de bits (nivells)</th>
        <th>Voltatge</th>
      </tr>
      <tr>
        <td>Arduino uno</td>
        <td>10 (0-1023)</td>
        <td>0-5V / 0-3.3V</td>
      </tr>
      <tr>
        <td>ESP32S3</td>
        <td>12 (0-4095)</td>
        <td>0-3.3V</td>
      </tr>
      <tr>
        <td>ADS1115</td>
        <td>16 (0-65536)</td>
        <td>0-3.3V</td>
      </tr>
    </thead>
  </table>
<p> A continuació tenim un codi general que pot servir per moltissimes coses diferents, i totes relacionades amb la capacitat que té l'Arduino de llegir de 0 a 1023 en una entrada analògica, si fos un ESP32S3 llegiria de 0 a 4095 i si fos un ADS1115 llegiria de 0 a 65536. Per què?
Els microxips i els microcontroladors tenen transistors i aquests només poden fer una cosa, encendre's o apagar-se, és a dir 0 o 1 i cada bit és un 0 o 1. Si tenim 12 bits en un ADC (Analog Digital Converter) significa que té 2 <sub>12</sub> combinacions de zeros i uns, és a dir, 4096 nivells diferents que numericamentva des del 0 al 4095. Ara justifiquem el número 65536 seria correcte si fos 2<sup>16</sup> com diu el fabricant, pero al datasheet parla d'un nivell màxim de 8000h (Nùmero hexadecimalque corrwspon a 32768) es a dir són 15 bits utilitzables. Sempre s'ha de comprobar el <a href="#"> datasheet o  fulla de característiques </a>del fabricant</p>
 
  <pre><code>
    int valor_ADC=0;  // Int significa integer o valor enter numéric (float seria "floating point number o decimal", char seria un character o caracter de lletra de l'alfabet, string seria una cadena de caràcters o paraula, etc. El més important és que la primera paraula defineix el tipus de paraula que tenim, en aquest cas enter). "valor_ADC" és un nom que triem nsaltrs per definir una variable, és a dir, un valor que no serà constant, i que té inicialment un valor 0, si posem int valor_ADC; és a dir, no posem que és igual a 0 per defecte hauria de donar valor 0. Si jo volgués posar un potenciomentre possaria pot i si volgués posar un LDR posaria ldr en minúscula. Sempre la primera línea és la definici´de les variables. A vegades abans de la primera línea necessitem carregar biblioteques. 
    void setup(){    //9600 en Arduino 
                    // Sempre hi ha un setup o funció de configuració del microcontrolador en llenguatge Arduino que té un parentasis buit perquè no té cap paràmetre o argument del qual depengui en molts casos. La paraula void seria l'equivalent a la paraula function en JavaScript. També es diu void setup en Processing perquè deriva de Processing aquest llenguatge. Posem una clau per agrupar totes les instruccions que volem executar una sola vegada, perque setup s'executa només al principi quan arranquen o encenem l'Arduino o microcontrolador.  
    Serial_begin(9600);  //115200 en S3
                        // Serial s'escriu amb majuscules perquè és una classe que és una part important del codi Arduino que antigamnt era una classe de Processing i té un métode que es fa servir amb la sintaxi del punt, dot syntax que consisteix en que quan j escric un punt estic aplicant un mètode normalment a un objecte d'una classe i a vegades a una classe, com aquí. El mètode begin connecta per al cable serie del ordinador amb l'Arduino, i té només un paràmetre que és un número enter que correspon a la velocitat en bits/segon. Pel cas de l'Arduino Uno 9600 bits/segon o bauds, mentres que en ESP32S3 són 115200 bits/segon o bauts "Serial.begin (115200)". És molt important posar un ; en cada insucció per informar que ja ha acabat.   
    }
    void loop(){          // És una funció que repeteix sense parar fins que desconecto físicament o poso un codi per aturar-ho
    valor ADC=analogRead(A0);  //34 en S3
                              // La variable que hem creat abans, que era 0 inicialment ara canviarà perquè la instrucció analogRead el que fa és llegir valors entre 0 i 1023 si es un Arduino Uno, A0 és una de les 6 entrades analògiques
    valor_ADC=analogRead(34); // La variable de valor 0 ara estarà entre els valors 0 i 4095 Perquè és un microcontrolador de 12 bits ADC
                    //ADC és Analog Digital converter, és a dir que convertim un valor analògic en digital (convertidor analògic digital)
                    // DAC és Digital Analog Converter, és a dir el contrari que ADC, convertim digital a analògic com el PWM (Pulse Width Modlation) que vol dir modulació de l'ample de banda
                // D'acord amb el <a src="https://www.espressif.com/sites/default/files/documentation/esp32-s3_datasheet_en.pdf"> datasheet o fulla de caracterísitques de ESP32S3 </a>
                // Hi ha 20 entrades analògiques de 12 bits mentres que en Arduino Uno hi ha 6 entrades analògiques de 10 bits
    Serial.println(valorADC); (imprimeixi via serial el valor de ADC)
    delay(500); (espera 500 milisegons)
  </code></pre>
</body>
</html>
